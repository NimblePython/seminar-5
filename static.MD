# Статические члены класса в C++

Кроме переменных и методов, которые относятся непосредственно к объекту, C++ позволяет определять переменные и методы, которые относятся ко всему классу. Такие члены класса называются **статическими**, и для их объявления используется ключевое слово `static`.

## Статические поля

Статические переменные обычно применяются для хранения значений, общих для всех объектов класса. То есть они сохраняют состояние всего класса. Статическая переменная определяется один раз и будет существовать, даже если объекты класса не были созданы.

Примером статической переменной может служить счётчик созданных объектов:

```cpp
#include <iostream>
 
class Person {
public:
    Person(std::string p_name, unsigned p_age) {
        ++count; // Увеличиваем счетчик при создании объекта
        name = p_name;
        age = p_age;
    }

    void print_count() {
        std::cout << "Created " << count << " objects" << std::endl;
    }

private:
    std::string name;
    unsigned age;
    static inline unsigned count{};  // Статическое поле - счетчик объектов Person
};
 
int main() {
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};
    Person sam{"Sam", 25};
    tom.print_count();  // Вывод: Created 3 objects
    bob.print_count();  // Вывод: Created 3 objects
    sam.print_count();  // Вывод: Created 3 objects
}
```

Здесь статическая переменная `count` относится ко всему классу, и ее значение увеличивается при создании каждого нового объекта.

## Статические функции

Статические функции принадлежат классу в целом и обычно используются для работы со статическими переменными. Например, в функции `print_count()` выводится значение статической переменной `count`, и эта функция не зависит от конкретного объекта:

```cpp
#include <iostream>
 
class Person {
public:
    Person(std::string p_name, unsigned p_age) {
        ++count;
        name = p_name;
        age = p_age;
    }

    static void print_count() {  // Статическая функция
        std::cout << "Created " << count << " objects" << std::endl;
    }

private:
    std::string name;
    unsigned age;
    static inline unsigned count{};  // Статическое поле
};
 
int main() {
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};
    Person sam{"Sam", 25};

    Person::print_count();  // Вывод: Created 3 objects
}
```

К статической функции можно обращаться через объект, но лучше использовать синтаксис `Person::print_count()`.

## Обращение к статическим членам

Для обращения к статическим переменным и функциям можно использовать синтаксис `класс::член_класса`:

```cpp
#include <iostream>
 
class Person {
public:
    static inline unsigned maxAge{120}; // Статическая переменная
    Person(std::string p_name, unsigned p_age) {
        ++count;
        name = p_name;
        if (p_age < maxAge) {
            age = p_age;
        }
    }

    static void print_count() {  // Статическая функция
        std::cout << "Created " << count << " objects" << std::endl;
    }

private:
    std::string name;
    unsigned age{1};
    static inline unsigned count{};  // Статическое поле
};
 
int main() {
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};

    Person::print_count();  // Вывод: Created 2 objects
    std::cout << "Max age: " << Person::maxAge << std::endl;  // Вывод: Max age: 120
}
```

## Статические константы

Если значение статической переменной не должно изменяться, её можно сделать константой:

```cpp
#include <iostream>

class Person {
public:
    static inline const unsigned maxAge{120};  // Статическая константа
    Person(std::string p_name, unsigned p_age) {
        ++count;
        name = p_name;
        if (p_age < maxAge) {
            age = p_age;
        }
    }

    static void print_count() {
        std::cout << "Created " << count << " objects" << std::endl;
    }

private:
    std::string name;
    unsigned age{1};
    static inline unsigned count{};  // Статическое поле
};
 
int main() {
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};

    Person::print_count();  // Вывод: Created 2 objects
    std::cout << "Max age: " << Person::maxAge << std::endl;  // Вывод: Max age: 120
}
```

## Ключевое слово inline

Ключевое слово `inline` для статических переменных в C++ используется для удобства их инициализации прямо в теле класса, начиная с стандарта C++17.

До C++17 статические переменные нужно было объявлять внутри класса, а затем определять и инициализировать их отдельно, обычно в файле реализации (`.cpp`). Это создавало лишнюю бюрократию и увеличивало вероятность ошибок, связанных с порядком инициализации. Например, нужно было следить за тем, чтобы переменные были правильно определены вне класса.

Пример до C++17:

```cpp
class MyClass {
public:
    static int count;
};

// Определение и инициализация переменной вне класса
int MyClass::count = 0;
```

С введением `inline` в C++17 стало возможным инициализировать статические переменные прямо внутри класса, что упрощает код:

```cpp
class MyClass {
public:
    static inline int count = 0;  // Определение и инициализация в одном месте
};
```

**Зачем нужно `inline`?**

- **Предотвращение множественного определения**: Без ключевого слова `inline`, статическая переменная, объявленная в заголовочном файле и включённая в несколько единиц трансляции (несколько файлов `.cpp`), вызвала бы ошибку компоновки, так как переменная будет определена несколько раз. `inline` сообщает компилятору, что эта переменная может быть определена в нескольких местах, но фактически она будет существовать только в одном экземпляре на уровне программы.
  
- **Упрощение кода**: Это позволяет избежать необходимости писать определения статических переменных отдельно в файле реализации, упрощая поддержку и понимание кода.

Таким образом, `inline` в сочетании со `static` для переменных внутри класса помогает избежать ошибок множественного определения, упрощает код и улучшает его читаемость.

**Итого**: статические члены класса позволяют хранить значения и методы, общие для всех объектов класса, что удобно для задач, где требуется отслеживать или управлять состоянием класса в целом.
